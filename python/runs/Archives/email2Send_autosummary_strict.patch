diff --git a/modules/Emails/Email.php b/modules/Emails/Email.php
--- a/modules/Emails/Email.php
+++ b/modules/Emails/Email.php
@@ -1,3 +1,4 @@
 /**
  * 
  * ...
  */
+ 
 public function email2Send($request)
 {
     global $mod_strings;
     global $app_strings;
     global $current_user;
     global $sugar_config;
     global $locale;
     global $timedate;
     global $beanList;
     global $beanFiles;

     $OBCharset = $locale->getPrecedentPreference('default_email_charset');
     $ie = null;

     /**********************************************************************
      * Sugar Email PREP
      */
     /* preset GUID */

     $orignialId = "";
     if (!empty($this->id)) {
         $orignialId = $this->id;
     } // if

     if (empty($this->id)) {
         $this->id = create_guid();
         $this->new_with_id = true;
     }

     /* satisfy basic HTML email requirements */
     $this->name = $request['sendSubject'];
     $this->description_html = '&lt;html&gt;&lt;body&gt;' . $request['sendDescription'] . '&lt;/body&gt;&lt;/html&gt;';

     /**********************************************************************
      * PHPMAILER PREP
      */
     $mail = new SugarPHPMailer();
     $mail = $this->setMailer($mail, '', $request['fromAccount']);
     if (empty($mail->Host) && !$this->isDraftEmail($request)) {
         $this->status = 'send_error';

         if ($mail->oe->type == 'system') {
             echo($app_strings['LBL_EMAIL_ERROR_PREPEND'] . $app_strings['LBL_EMAIL_INVALID_SYSTEM_OUTBOUND']);
         } else {
             echo($app_strings['LBL_EMAIL_ERROR_PREPEND'] . $app_strings['LBL_EMAIL_INVALID_PERSONAL_OUTBOUND']);
         }

         return false;
     }

     $subject = $this->name;
     $mail->Subject = from_html($this->name);

     // work-around legacy code in SugarPHPMailer
     if ($request['setEditor'] == 1) {
         $request['description_html'] = $request['sendDescription'];
         $this->description_html = $request['description_html'];
     } else {
         $this->description_html = '';
         $this->description = $request['sendDescription'];
     }
     // end work-around

     if ($this->isDraftEmail($request)) {
         if ($this->type != 'draft' && $this->status != 'draft') {
             $this->id = create_guid();
             $this->new_with_id = true;
             $this->date_entered = "";
         } // if
         $q1 = "update emails_email_addr_rel set deleted = 1 WHERE email_id = '{$this->id}'";
         $r1 = $this->db->query($q1);
     } // if

     if (isset($request['saveDraft'])) {
         $this->type = 'draft';
         $this->status = 'draft';
         $forceSave = true;
     } else {
         /* Apply Email Templates */
         // do not parse email templates if the email is being saved as draft....
         $toAddresses = $this->email2ParseAddresses($request['sendTo']);
         $sea = new SugarEmailAddress();
         $object_arr = array();

         if (isset($request['parent_type']) && !empty($request['parent_type']) &&
             isset($request['parent_id']) && !empty($request['parent_id']) &&
             in_array($request['parent_type'], ['Accounts', 'Cases', 'Contacts', 'Leads', 'Users', 'Prospects'])) {
             if (isset($beanList[$request['parent_type']]) && !empty($beanList[$request['parent_type']])) {
                 $className = $beanList[$request['parent_type']];
                 if (isset($beanFiles[$className]) && !empty($beanFiles[$className])) {
                     if (!class_exists($className)) {
                         require_once($beanFiles[$className]);
                     }
                     $bean = new $className();
                     $bean->retrieve($request['parent_id']);
                     $object_arr[$bean->module_dir] = $bean->id;
                 } // if
             } // if
         }
         foreach ($toAddresses as $addrMeta) {
             $addr = $addrMeta['email'];
             $beans = $sea->getBeansByEmailAddress($addr);
             foreach ($beans as $bean) {
                 if (!isset($object_arr[$bean->module_dir])) {
                     $object_arr[$bean->module_dir] = $bean->id;
                 }
             }
         }

         /* template parsing */
         if (empty($object_arr)) {
             $object_arr= array('Contacts' => '123');
         }
         $object_arr['Users'] = $current_user->id;
         $this->description_html = EmailTemplate::parse_template($this->description_html, $object_arr);
         $this->name = EmailTemplate::parse_template($this->name, $object_arr);
         $this->description = EmailTemplate::parse_template($this->description, $object_arr);
         $this->description = html_entity_decode((string) $this->description, ENT_COMPAT, 'UTF-8');
         if ($this->type != 'draft' && $this->status != 'draft') {
             $this->id = create_guid();
             $this->date_entered = "";
             $this->new_with_id = true;
             $this->type = 'out';
             $this->status = 'sent';
         }
     }

     if (isset($request['parent_type']) && empty($request['parent_type']) &&
         isset($request['parent_id']) && empty($request['parent_id'])) {
         $this->parent_id = "";
         $this->parent_type = "";
     } // if

     $mail->Subject = $this->name;
     $mail = $this->handleBody($mail);
     $mail->Subject = $this->name;
     $this->description_html = from_html($this->description_html);
     $this->description_html = $this->decodeDuringSend($this->description_html);
     $this->description = $this->decodeDuringSend($this->description);

     /* from account */
     $replyToAddress = $current_user->emailAddress->getReplyToAddress($current_user, true);
     $replyToName = "";
     if (empty($request['fromAccount'])) {
         $defaults = $current_user->getPreferredEmail();
         $mail->From = $defaults['email'];
         isValidEmailAddress($mail->From);

         if ($fromname = $defaults['name']) {
             $mail->FromName = $fromname;
         } else {
             $mail->FromName = $current_user->name;
         }
     } else {
         // passed -> user -> system default
         $ie = BeanFactory::newBean('InboundEmail');
         $ie->retrieve($request['fromAccount']);
         $storedOptions = sugar_unserialize(base64_decode($ie->stored_options));
         $fromName = "";
         $fromAddress = "";
         $replyToName = "";
         if (!empty($storedOptions)) {
             $fromAddress = $storedOptions['from_addr'];
             isValidEmailAddress($fromAddress);
             $fromName = from_html($storedOptions['from_name']);
             $replyToAddress = (isset($storedOptions['reply_to_addr']) ? $storedOptions['reply_to_addr'] : "");
             $replyToName = (isset($storedOptions['reply_to_name']) ? from_html($storedOptions['reply_to_name']) : "");
         } // if
         $defaults = $current_user->getPreferredEmail();
         if ($ie->is_personal) {
             if (empty($replyToAddress)) {
                 $replyToAddress = $current_user->emailAddress->getReplyToAddress($current_user, true);
             } // if
             if (empty($replyToName)) {
                 $replyToName = $defaults['name'];
             } // if
             if (!empty($storedOptions['reply_to_addr'])) {
                 $replyToAddress = $storedOptions['reply_to_addr'];
             }
         }
         $mail->From = (!empty($fromAddress)) ? $fromAddress : $defaults['email'];
         isValidEmailAddress($mail->From);
         $mail->FromName = (!empty($fromName)) ? $fromName : $defaults['name'];
         $replyToName = (!empty($replyToName)) ? $replyToName : $mail->FromName;
     }

     $mail->Sender = $mail->From; /* set Return-Path field in header to reduce spam score in emails sent via Sugar's Email module */
     isValidEmailAddress($mail->Sender);

     if (!empty($replyToAddress)) {
         $mail->AddReplyTo($replyToAddress, $locale->translateCharsetMIME(trim($replyToName), 'UTF-8', $OBCharset));
     } else {
         $mail->AddReplyTo($mail->From, $locale->translateCharsetMIME(trim($mail->FromName), 'UTF-8', $OBCharset));
     } // else
     $emailAddressCollection = array(); // used in linking to beans below
     // handle to/cc/bcc
     foreach ($this->email2ParseAddresses($request['sendTo']) as $addr_arr) {
         if (empty($addr_arr['email'])) {
             continue;
         }

         if (empty($addr_arr['display'])) {
             $mail->AddAddress($addr_arr['email'], "");
         } else {
             $mail->AddAddress(
                 $addr_arr['email'],
                 $locale->translateCharsetMIME(trim($addr_arr['display']), 'UTF-8', $OBCharset)
             );
         }
         $emailAddressCollection[] = $addr_arr['email'];
     }
     foreach ($this->email2ParseAddresses($request['sendCc']) as $addr_arr) {
         if (empty($addr_arr['email'])) {
             continue;
         }

         if (empty($addr_arr['display'])) {
             $mail->AddCC($addr_arr['email'], "");
         } else {
             $mail->AddCC(
                 $addr_arr['email'],
                 $locale->translateCharsetMIME(trim($addr_arr['display']), 'UTF-8', $OBCharset)
             );
         }
         $emailAddressCollection[] = $addr_arr['email'];
     }

     foreach ($this->email2ParseAddresses($request['sendBcc']) as $addr_arr) {
         if (empty($addr_arr['email'])) {
             continue;
         }

         if (empty($addr_arr['display'])) {
             $mail->AddBCC($addr_arr['email'], "");
         } else {
             $mail->AddBCC(
                 $addr_arr['email'],
                 $locale->translateCharsetMIME(trim($addr_arr['display']), 'UTF-8', $OBCharset)
             );
         }
         $emailAddressCollection[] = $addr_arr['email'];
     }

     /* parse remove attachments array */
     $removeAttachments = array();
     if (!empty($request['templateAttachmentsRemove'])) {
         $exRemove = explode("::", $request['templateAttachmentsRemove']);

         foreach ($exRemove as $file) {
             $removeAttachments = substr($file, 0, 36);
         }
     }

     /* handle attachments */
     if (!empty($request['attachments'])) {
         $exAttachments = explode("::", $request['attachments']);

         foreach ($exAttachments as $file) {
             $file = trim(from_html($file));
             $file = str_replace("\\", "", $file);
             if (!empty($file)) {
                 //$fileLocation = $this->et->userCacheDir."/{$file}";
                 $fileGUID = preg_replace('/[^a-z0-9\-]/', "", substr($file, 0, 36));
                 $fileLocation = $this->et->userCacheDir . "/{$fileGUID}";
                 $filename = substr(
                     $file,
                     36,
                     strlen($file)
                 ); // strip GUID	for PHPMailer class to name outbound file

                 $mail->AddAttachment($fileLocation, $filename, 'base64', $this->email2GetMime($fileLocation));
                 //$mail->AddAttachment($fileLocation, $filename, 'base64');

                 // only save attachments if we're archiving or drafting
                 if ((($this->type == 'draft') && !empty($this->id)) || (isset($request['saveToSugar']) && $request['saveToSugar'] == 1)) {
                     $note = BeanFactory::newBean('Notes');
                     $note->id = create_guid();
                     $note->new_with_id = true; // duplicating the note with files
                     $note->parent_id = $this->id;
                     $note->parent_type = $this->module_dir;
                     $note->name = $filename;
                     $note